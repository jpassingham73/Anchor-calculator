<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Elba45 Anchor Scope Calculator — v2</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

<style>
  :root{
    --bg:#0b1220;--card:#0f172a;--muted:#93a0b4;--accent:#06b6d4;--ok:#16a34a;--warn:#f59e0b;--bad:#dc2626;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:#e5edf6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:14px 18px;border-bottom:1px solid #1f2937;display:flex;align-items:center;gap:12px}
  header h1{font-size:1.05rem;margin:0}
  header .muted{color:var(--muted);font-size:.9rem}
  .wrap{max-width:1100px;margin:0 auto;padding:14px}
  .grid{display:grid;gap:12px}
  @media (min-width:980px){ .grid{grid-template-columns: 1.05fr 1.15fr} }
  .card{background:var(--card);border-radius:14px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  label{display:block;font-weight:600;margin-top:8px}
  input,select,button{width:100%;padding:10px;border-radius:10px;border:1px solid #334155;background:#0c1426;color:#e5edf6}
  button{background:var(--accent);border:none;font-weight:700;cursor:pointer}
  .muted{color:var(--muted)}
  #map{height:280px;border-radius:10px;overflow:hidden}
  .chart-wrap{height:260px;border-radius:10px;overflow:hidden;background:#0c1426;padding:8px}
  .pill{display:inline-block;border:1px solid #1f2937;border-radius:999px;padding:4px 10px;margin:2px;font-size:.85rem;color:#b8c4d8}
  .result{padding:14px;border-radius:12px;margin-top:10px;font-weight:700;text-align:center}
  .ok{background:rgba(22,163,74,.12);border:1px solid rgba(22,163,74,.4);color:#b2f5bf}
  .warn{background:rgba(245,158,11,.12);border:1px solid rgba(245,158,11,.4);color:#fde68a}
  .bad{background:rgba(220,38,38,.12);border:1px solid rgba(220,38,38,.4);color:#fecaca}
  .small{font-size:.9rem}
</style>
</head>
<body>

<header>
  <svg width="36" height="36" viewBox="0 0 24 24" fill="none"><path d="M12 2l3 6h6l-5 4 2 8-6-4-6 4 2-8-5-4h6l3-6z" fill="#06b6d4"/></svg>
  <div>
    <h1>Elba45 Anchor Scope Calculator</h1>
    <div class="muted">Auto-location • Wind/Gust Chart • Optional seabed auto-detect (EU)</div>
  </div>
</header>

<div class="wrap grid">
  <section class="card">
    <div>
      <div class="pill">Boat: Elba 45</div>
      <div class="pill">Bow roller: <span id="bowHeightInfo">1.3 m</span></div>
      <div class="pill">Chain: 10 mm G40 (~<span id="chainW">2.4</span> kg/m in water)</div>
      <div class="pill">Bridle: 8 m / 20 mm Liros Squareline (polyester)</div>
    </div>

    <div id="map" style="margin-top:10px"></div>
    <div class="small muted" id="coords" style="margin-top:6px">Locating…</div>

    <div class="row" style="margin-top:8px">
      <div style="flex:1">
        <label>Water depth under keel (m)</label>
        <input id="depth" type="number" step="0.1" value="6">
      </div>
      <div style="flex:1">
        <label>Tide allowance to high water (m)</label>
        <input id="tide" type="number" step="0.1" value="0.5">
      </div>
    </div>

    <div class="row">
      <div style="flex:1">
        <label>Seabed</label>
        <select id="seabed">
          <option value="auto" selected>Auto (EUSeaMap when available)</option>
          <option value="sand">Sand (good)</option>
          <option value="firm_mud">Firm mud</option>
          <option value="soft_mud">Soft mud / weed</option>
          <option value="rock">Rock / poor bite</option>
          <option value="unknown">Unknown</option>
        </select>
      </div>
      <div style="flex:1">
        <label>Crowding (swing room)</label>
        <select id="crowd">
          <option value="normal" selected>Normal</option>
          <option value="tight">Tight</option>
          <option value="unlimited">Unlimited</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div style="flex:1">
        <label>Weather model</label>
        <select id="model">
          <option value="">Best match (auto)</option>
          <option value="gfs">GFS</option>
          <option value="ecmwf_ifs025">ECMWF IFS 0.25°</option>
          <option value="icon_seamless">ICON Seamless</option>
        </select>
      </div>
      <div style="flex:1">
        <label>Look-ahead (hours)</label>
        <select id="lookahead">
          <option value="6">6 h</option>
          <option value="12">12 h</option>
          <option value="24" selected>24 h</option>
        </select>
      </div>
    </div>

    <button id="calc" style="margin-top:8px">Calculate recommended chain</button>
    <div id="out" class="result ok">Waiting for weather…</div>
    <div id="notes" class="small muted" style="margin-top:6px"></div>
  </section>

  <section class="card">
    <div class="chart-wrap">
      <canvas id="windChart" width="800" height="240"></canvas>
    </div>
    <div class="small muted" id="modelInfo" style="margin-top:8px"></div>
  </section>
</div>

<script>
/* === Your boat defaults (updated chain weight 2.4 kg/m) === */
const DEFAULTS = {
  bowHeight: 1.3,           // m
  chainWeight: 2.4,         // kg/m in water  <-- UPDATED
  bridleLength: 8,          // m (polyester, low stretch ~3%)
  windageArea: 70           // m² broadside est.
};
document.getElementById('bowHeightInfo').textContent = DEFAULTS.bowHeight + " m";
document.getElementById('chainW').textContent = DEFAULTS.chainWeight.toFixed(1);

let map, marker, windChart = null;
let user = { lat:null, lon:null, weather:null, seabed:{code:'unknown', label:'Unknown', raw:null} };

/* ===== Map ===== */
function initMap(lat, lon){
  map = L.map('map', { zoomControl:false }).setView([lat, lon], 14);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'© OpenStreetMap' }).addTo(map);
  marker = L.marker([lat, lon]).addTo(map);
}
function updateMap(lat, lon){
  if(!map) return initMap(lat, lon);
  marker.setLatLng([lat, lon]);
  map.setView([lat, lon], 14);
}

/* ===== Weather (Open-Meteo) ===== */
async function fetchWeather(lat, lon){
  const lookahead = parseInt(document.getElementById('lookahead').value,10);
  const modelVal = document.getElementById('model').value;
  const params = new URLSearchParams({
    latitude: lat, longitude: lon,
    hourly: 'wind_speed_10m,wind_gusts_10m',
    forecast_hours: lookahead.toString(),
    wind_speed_unit: 'kn',
    timezone: 'auto'
  });
  if(modelVal) params.set('models', modelVal);
  const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error(`Weather error ${res.status}`);
  return await res.json();
}

/* ===== Chart (fixed-size, single instance) ===== */
function drawChart(times, windKn, gustKn){
  const ctx = document.getElementById('windChart').getContext('2d');
  if(windChart){ windChart.destroy(); windChart = null; }
  windChart = new Chart(ctx, {
    type:'line',
    data:{
      labels: times.map(t => t.slice(11,16)),
      datasets:[
        {label:'Wind (kn)', data: windKn, borderColor:'#06b6d4', tension:.25, pointRadius:0},
        {label:'Gusts (kn)', data: gustKn, borderColor:'#f97316', tension:.25, pointRadius:0}
      ]
    },
    options:{
      responsive:true,
      maintainAspectRatio:false,   // canvas height is controlled by .chart-wrap
      animation:false,
      scales:{
        x:{ ticks:{ color:'#9fb0c6' }, grid:{ color:'rgba(148,163,184,0.15)' }},
        y:{ ticks:{ color:'#9fb0c6' }, grid:{ color:'rgba(148,163,184,0.15)' }}
      },
      plugins:{ legend:{ labels:{ color:'#cbd5e1' }} }
    }
  });
}

/* ===== Seabed (EU only; silent fail if CORS) ===== */
async function fetchSeabedEU(lat, lon){
  const d = 0.01, bbox = [lon-d, lat-d, lon+d, lat+d].join(',');
  const base = 'https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms';
  const qs = `SERVICE=WMS&VERSION=1.3.0&REQUEST=GetFeatureInfo&CRS=CRS:84&WIDTH=101&HEIGHT=101&I=50&J=50&BBOX=${bbox}&INFO_FORMAT=application/json&QUERY_LAYERS=emodnet_view:EUSeaMap_2023_EUNIS2019&LAYERS=emodnet_view:EUSeaMap_2023_EUNIS2019`;
  try{
    const r = await fetch(`${base}?${qs}`, {mode:'cors'});
    if(r.ok){
      const j = await r.json();
      const f = j.features && j.features[0];
      if(f){
        const raw = (f.properties?.habitat || f.properties?.HABITAT || f.properties?.Description || '')+'';
        return classifySeabed(raw);
      }
    }
  }catch(e){/* ignore */ }
  return {code:'unknown', label:'Unknown', raw:null};
}
function classifySeabed(text){
  const t=(text||'').toLowerCase();
  if(/seagrass|posidonia|maerl|alg|veget/.test(t)) return {code:'soft_mud', label:'Seagrass/Weed', raw:text};
  if(/mud|silt|clayey/.test(t)) return {code:'firm_mud', label:'Mud', raw:text};
  if(/sand|sandy|gravelly sand/.test(t)) return {code:'sand', label:'Sand', raw:text};
  if(/gravel|pebble|cobble/.test(t)) return {code:'sand', label:'Gravel/Coarse', raw:text};
  if(/rock|reef|boulder/.test(t)) return {code:'rock', label:'Rock', raw:text};
  return {code:'unknown', label:'Unknown', raw:text};
}

/* ===== Scope rules ===== */
function baseScopeFromGust(g){
  if(g <= 12) return 4;
  if(g <= 20) return 5;
  if(g <= 30) return 7;
  if(g <= 40) return 8;
  return 10;
}
function seabedMultiplier(code){
  switch(code){
    case 'sand': return 1.0;
    case 'firm_mud': return 1.12;
    case 'soft_mud': return 1.3;
    case 'rock': return 1.5;
    default: return 1.2;
  }
}
function crowdingModifier(val){
  if(val==='tight') return 0.9;
  if(val==='unlimited') return 1.05;
  return 1.0;
}

/* Simple catenary heuristic (using your 2.4 kg/m) → for info only */
function catenaryRatio(chain_m, depth_m, gust_kn){
  const g = 9.81, W = DEFAULTS.chainWeight * chain_m * g; // N
  const v = gust_kn * 0.514444, rho=1.225, Cd=1.2;
  const windN = 0.5*rho*Cd*DEFAULTS.windageArea*v*v;
  const verticalFraction = Math.min(1, depth_m / Math.max(0.5, chain_m));
  const verticalSupport = W * verticalFraction * 1.2; // safety factor
  return (verticalSupport / Math.max(1, windN));
}

/* ===== Calculation ===== */
function calculateNow(){
  const out = document.getElementById('out');
  const notesEl = document.getElementById('notes');
  const depth = parseFloat(document.getElementById('depth').value)||0;
  const tide = parseFloat(document.getElementById('tide').value)||0;
  const seabedSel = document.getElementById('seabed').value;
  const crowd = document.getElementById('crowd').value;

  const workingDepth = depth + tide + DEFAULTS.bowHeight;

  // Peak gust from loaded data (kn)
  let peakG = 15;
  if(user.weather?.hourly?.wind_gusts_10m?.length){
    peakG = Math.max(...user.weather.hourly.wind_gusts_10m);
  } else if(user.weather?.hourly?.wind_speed_10m?.length){
    peakG = Math.max(...user.weather.hourly.wind_speed_10m);
  }

  let scope = baseScopeFromGust(peakG);
  if(peakG > 25) scope *= 1.10;           // polyester bridle compensation
  const seabedCode = (seabedSel==='auto' ? user.seabed.code : seabedSel);
  scope *= seabedMultiplier(seabedCode);
  scope *= crowdingModifier(crowd);

  const chainRequired = Math.ceil(scope * workingDepth);

  // Result styling
  let cls='ok'; if(scope>=7 && scope<10) cls='warn'; if(scope>=10) cls='bad';
  out.className = `result ${cls}`;
  out.innerHTML = `Chain to veer: <strong>${chainRequired} m</strong> &nbsp; (scope <strong>${scope.toFixed(1)}:1</strong>, working depth <strong>${workingDepth.toFixed(2)} m</strong>)`;

  // Info notes
  const seabedLabel = (seabedSel==='auto')
    ? `${user.seabed.label}${user.seabed.raw?` <span class="muted">(“${user.seabed.raw}”)</span>`:''}`
    : seabedSel.replace('_',' ');
  const ratio = catenaryRatio(chainRequired, workingDepth, peakG);
  notesEl.innerHTML = `
    Peak gust next ${document.getElementById('lookahead').value}h: <strong>${peakG.toFixed(0)} kn</strong><br/>
    Seabed: <strong>${seabedLabel}</strong><br/>
    Catenary heuristic ratio: <strong>${ratio.toFixed(2)}</strong> (≥1.2 is good).<br/>
    Tip: if it gets lumpy, add scope (+20–30%) or lengthen the bridle.
  `;
}

/* ===== Bootstrap (auto-location) ===== */
async function bootstrap(){
  navigator.geolocation.getCurrentPosition(async pos=>{
    user.lat = pos.coords.latitude; user.lon = pos.coords.longitude;
    document.getElementById('coords').textContent = `Lat ${user.lat.toFixed(5)}, Lon ${user.lon.toFixed(5)}`;
    updateMap(user.lat, user.lon);

    try{
      user.weather = await fetchWeather(user.lat, user.lon);
      const times = user.weather.hourly.time;
      drawChart(times, user.weather.hourly.wind_speed_10m, user.weather.hourly.wind_gusts_10m);
      document.getElementById('modelInfo').textContent =
        (document.getElementById('model').value ? `Model: ${document.getElementById('model').selectedOptions[0].text}` : 'Model: Best match (auto)');
    }catch(err){
      document.getElementById('modelInfo').textContent = `Weather error: ${err.message}`;
    }

    if(document.getElementById('seabed').value==='auto'){
      user.seabed = await fetchSeabedEU(user.lat, user.lon);
    }
    calculateNow();
  }, err=>{
    document.getElementById('coords').textContent = `Location error: ${err.message}`;
  });
}

/* Re-draw and re-calc on changes (with chart single-instance guard) */
document.getElementById('calc').addEventListener('click', calculateNow);
['depth','tide','seabed','crowd','lookahead','model'].forEach(id=>{
  document.getElementById(id).addEventListener('change', async ()=>{
    if(id==='model' && user.lat && user.lon){
      try{
        user.weather = await fetchWeather(user.lat, user.lon);
        const times = user.weather.hourly.time;
        drawChart(times, user.weather.hourly.wind_speed_10m, user.weather.hourly.wind_gusts_10m);
      }catch(e){}
    }
    calculateNow();
  });
});

bootstrap();
</script>
</body>
</html>
