<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elba45 Anchor Scope Calculator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #f4f6f8; margin: 0; padding: 0; }
        header { background: #004d7a; color: white; padding: 1rem; text-align: center; font-size: 1.5rem; }
        .container { display: flex; flex-wrap: wrap; padding: 1rem; gap: 1rem; }
        .card { background: white; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 1rem; flex: 1; }
        #map { height: 300px; border-radius: 10px; }
        #scopeResult { font-size: 1.3rem; font-weight: bold; padding: 1rem; border-radius: 10px; margin-top: 1rem; text-align: center; }
        .safe { background-color: #d4edda; color: #155724; }
        .borderline { background-color: #fff3cd; color: #856404; }
        .short { background-color: #f8d7da; color: #721c24; }
        @media (min-width: 900px) {
            .left, .right { flex: 1; min-width: 45%; }
        }
    </style>
</head>
<body>
<header>Elba45 Anchor Scope Calculator</header>
<div class="container">
    <div class="card left">
        <div id="map"></div>
        <p id="coords"></p>
    </div>
    <div class="card right">
        <canvas id="windChart" height="200"></canvas>
        <div id="scopeResult"></div>
    </div>
</div>
<script>
const bridleLength = 8; // metres
const chainDiameter = 10; // mm
const safetyFactor = 5; // default scope ratio

let map, marker, windChart;

// Initialise map
function initMap(lat, lon) {
    map = L.map('map').setView([lat, lon], 14);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);
    marker = L.marker([lat, lon]).addTo(map);
}

// Update marker
function updateMap(lat, lon) {
    if (!map) initMap(lat, lon);
    marker.setLatLng([lat, lon]);
    map.setView([lat, lon], 14);
}

// Fetch weather (Open-Meteo free API)
async function fetchWeather(lat, lon) {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=windspeed_10m,windgusts_10m&forecast_days=1`;
    const res = await fetch(url);
    const data = await res.json();
    return {
        hours: data.hourly.time.map(t => t.slice(11,16)),
        wind: data.hourly.windspeed_10m,
        gust: data.hourly.windgusts_10m
    };
}

// Fetch seabed type (EMODnet API)
async function fetchSeabedType(lat, lon) {
    const url = `https://ows.emodnet-seabedhabitats.eu/geoserver/emodnet_view/wms?service=WMS&version=1.3.0&request=GetFeatureInfo&layers=EUSeaMap:EUSeaMap_2023_EUNIS2019&bbox=${lon-0.01},${lat-0.01},${lon+0.01},${lat+0.01}&width=1&height=1&srs=EPSG:4326&format=application/json&info_format=application/json`;
    const res = await fetch(url);
    const data = await res.json();
    const feature = data.features[0];
    if (feature) {
        const habitat = feature.properties.habitat;
        return habitat ? habitat : 'Unknown';
    }
    return 'Unknown';
}

// Draw wind chart
function drawWindChart(labels, wind, gust) {
    const ctx = document.getElementById('windChart').getContext('2d');
    if (windChart) windChart.destroy();
    windChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                { label: 'Wind Speed (kn)', data: wind, borderColor: '#007bff', fill: false },
                { label: 'Wind Gusts (kn)', data: gust, borderColor: '#ff0000', fill: false }
            ]
        },
        options: { responsive: true, maintainAspectRatio: false }
    });
}

// Scope calculation
function calculateScope(maxWind, depth, seabedType) {
    let ratio = safetyFactor;
    if (seabedType === 'Mud' || seabedType === 'Seagrass') ratio = 7;
    if (seabedType === 'Rock') ratio = 3;
    if (maxWind > 20) ratio = 7;
    if (maxWind > 30) ratio = 10;
    const totalScope = depth * ratio;
    const chainLength = totalScope - bridleLength;
    return { chain: Math.max(chainLength, 0), ratio };
}

// Show result card
function showScopeResult(chain, ratio) {
    const resultDiv = document.getElementById('scopeResult');
    let cls = 'safe';
    if (ratio >= 7 && ratio < 10) cls = 'borderline';
    if (ratio >= 10) cls = 'short';
    resultDiv.className = cls;
    resultDiv.textContent = `Recommended Chain: ${chain.toFixed(1)} m (Scope ratio ${ratio}:1)`;
}

// Main auto-start
navigator.geolocation.getCurrentPosition(async pos => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    document.getElementById('coords').textContent = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}`;
    updateMap(lat, lon);
    const weather = await fetchWeather(lat, lon);
    drawWindChart(weather.hours, weather.wind, weather.gust);
    const maxWind = Math.max(...weather.wind, ...weather.gust);
    const depth = prompt("Enter water depth at bow (m):", "5");
    if (depth) {
        const seabedType = await fetchSeabedType(lat, lon);
        const { chain, ratio } = calculateScope(maxWind, parseFloat(depth), seabedType);
        showScopeResult(chain, ratio);
    }
}, err => {
    alert("Location permission denied or unavailable.");
});
</script>
</body>
</html>
